# ~/.bashrc â€” snippet loader + toggler for ~/.bashrc.d
# Conventions:
#   - Enabled:  ~/.bashrc.d/NN-name
#   - Disabled: ~/.bashrc.d/_NN-name   (leading underscore)
#   - Load order is numeric (NN)

BASHRC_D="${HOME}/.bashrc.d"

# ---- Loader ---------------------------------------------------------------

bashrcd_source_all() {
  [[ -d "$BASHRC_D" ]] || return 0

  local f
  shopt -s nullglob
  # only enabled snippets, in stable numeric order
  for f in "$BASHRC_D"/[0-9][0-9]-*; do
    [[ -r "$f" ]] || continue
    # shellcheck source=/dev/null
    . "$f"
  done
  shopt -u nullglob
}

bashrcd_source_all

# ---- Toggle helper ---------------------------------------------------------
# Usage:
#   bashrcd list
#   bashrcd on  80-curl
#   bashrcd off 80-curl
#   bashrcd toggle 80-curl
#   bashrcd on  80        # works with just the number too
#
# Notes:
#   - Renames files atomically within ~/.bashrc.d.
#   - Refuses to act if the target is ambiguous (multiple matches).

bashrcd() {
  [[ -d "$BASHRC_D" ]] || { echo "No dir: $BASHRC_D" >&2; return 2; }

  local cmd="${1:-list}" key="${2:-}"

  _bashrcd_resolve_one() {
    # prints exactly one matching path or returns nonzero
    local k="$1" matches=()
    shopt -s nullglob

    if [[ "$k" =~ ^[0-9][0-9]$ ]]; then
      matches=( "$BASHRC_D"/"$k"-* "$BASHRC_D"/_"$k"-* )
    else
      matches=( "$BASHRC_D"/"$k" "$BASHRC_D"/_"$k" )
      # if they passed "NN-name", accept globbing by exact prefix too
      matches+=( "$BASHRC_D"/"$k"* "$BASHRC_D"/_"$k"* )
    fi

    shopt -u nullglob

    # de-dup while preserving order (cheap)
    local uniq=() m seen
    for m in "${matches[@]}"; do
      seen=0
      for u in "${uniq[@]}"; do [[ "$u" == "$m" ]] && { seen=1; break; }; done
      [[ $seen -eq 0 ]] && uniq+=( "$m" )
    done

    if [[ "${#uniq[@]}" -eq 0 ]]; then
      echo "No match for: $k" >&2
      return 3
    fi
    if [[ "${#uniq[@]}" -gt 1 ]]; then
      echo "Ambiguous: $k" >&2
      printf '  %s\n' "${uniq[@]}" >&2
      return 4
    fi

    printf '%s\n' "${uniq[0]}"
  }

  case "$cmd" in
    list)
      shopt -s nullglob
      echo "# enabled:"
      ls -1 "$BASHRC_D"/[0-9][0-9]-* 2>/dev/null | sed 's#.*/##' || true
      echo
      echo "# disabled:"
      ls -1 "$BASHRC_D"/_[0-9][0-9]-* 2>/dev/null | sed 's#.*/_##' || true
      shopt -u nullglob
      ;;
    on|enable)
      [[ -n "$key" ]] || { echo "Usage: bashrcd on <NN|NN-name|file>" >&2; return 2; }
      local path base new
      path="$(_bashrcd_resolve_one "$key")" || return $?
      base="$(basename "$path")"
      [[ "$base" == _* ]] || { echo "Already enabled: $base" >&2; return 0; }
      new="${base#_}"
      mv -n -- "$path" "$BASHRC_D/$new"
      ;;
    off|disable)
      [[ -n "$key" ]] || { echo "Usage: bashrcd off <NN|NN-name|file>" >&2; return 2; }
      local path base new
      path="$(_bashrcd_resolve_one "$key")" || return $?
      base="$(basename "$path")"
      [[ "$base" == _* ]] && { echo "Already disabled: ${base#_}" >&2; return 0; }
      new="_$base"
      mv -n -- "$path" "$BASHRC_D/$new"
      ;;
    toggle)
      [[ -n "$key" ]] || { echo "Usage: bashrcd toggle <NN|NN-name|file>" >&2; return 2; }
      local path base
      path="$(_bashrcd_resolve_one "$key")" || return $?
      base="$(basename "$path")"
      if [[ "$base" == _* ]]; then
        bashrcd on "${base#_}"
      else
        bashrcd off "$base"
      fi
      ;;
    *)
      echo "Usage: bashrcd {list|on|off|toggle} [NN|NN-name|file]" >&2
      return 2
      ;;
  esac
}
